buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.

  ;next_options
  ;destination
  capacity
  line_id
  itinerary
  route_position
  direction       ; Direction wrt itinerary
  other-buses-on-my-line
]
 
globals [graph]

to init-buses
  ; Initialize your agents here.
  
  set inbox []
  set other-buses-on-my-line []

  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]

  ; only use this to initialize agent variables, everything else in execute=actions 

  show (word "Adding bus of type " bus_type " and line " line_id)

  if bus_type = 1
  [
    
    set capacity 12
  ]
  
  if bus_type = 2
  [
    set capacity 60
  ]
  
  if bus_type = 3
  [
    set capacity 150
  ]

  set-line line_id
  
  ; North line
  ;if member? bus_id [24]
  ;[
  ;   set-line 1
  ;]
  
  ; East line
  ;if  member? bus_id [25]
  ;[
  ;  set-line 2
  ;]
  
  ; South line
  ;if  member? bus_id [26]
  ;[
  ;   set-line 3 
  ;]
  
    ; West line
  ;if  member? bus_id [27]
  ;[
  ;   set-line 4
  ;]
  
  set route_position 0 
  
  ifelse (bus_id mod 2) = 0 
  [
    set direction 1 
  ]
  [
    set direction -1 
  ]
  
  set color green;
  

end


to set-line [line_idd]
  set line_id line_idd
  set itinerary get_stops_for_line line_idd
  let my_id bus_id
  ask buses
  [
    let mess list 1 my_id
    set mess lput line_idd mess
    
    if bus_id != my_id
    [
      send-message bus_id mess
    ]
  ]
end


to-report get_stops_for_line [l_id]
  ; North line
  if l_id = 1
  [
    report [3 9 8 2 8 6 8 9]
  ]
  
  ; East line
  if l_id = 2
  [
    report [3 20 12 15 18 15 0 22 21 20]
  ]
  
  ; South line
  if l_id = 3
  [
    report [3 4 10 13 23 14 23 19 1 7 17 10 4] 
  ]
  
  ; West line
  if l_id = 4
  [
    report [3 4 5 17 11 16] 
  ]
end


to execute-actions
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.
  
  if bus_id = 24
  [
    if (count buses) < 4
    [
      ; Just add 19 buses :)
      
      if ticks mod 5 = 0 [
        add-bus 3 count buses + 1
      ]
    ]
  ]
  
  if length inbox > 0
  [
    let other_busy_buses 0
    let received_responses 0
    
    foreach inbox
    [
      ; type 1 message
      if item 0 item 2 ?1 = 1
      [
        let other-bus-id item 1 item 2 ?1
        
        ; if it's on my line, add the sender id to the list
        if item 2 item 2 ?1 = line_id and not member? other-bus-id other-buses-on-my-line
        [
          set other-buses-on-my-line lput other-bus-id other-buses-on-my-line
          
          let response list 1 bus_id
          set response lput line_id response
          
          send-message other-bus-id response
        ]
      ]
      
      ; type 2 message
      if item 0 item 2 ?1 = 2
      [
        let fullness 0
        if length bus_passengers > (0.95 * capacity)
        [
          set fullness 1
        ]
        let response list 3 fullness
        let transmitter_id item 1 item 2 ?1
        ;show(word "Transmitter ID: " transmitter_id)
        send-message transmitter_id response
      ]
      
      ; type 3 message
      if item 0 item 2 ?1 = 3
      [
        set received_responses received_responses + 1
        let fullness item 1 item 2 ?1
        show(word "Received response " fullness)
        if fullness = 1
        [
          set other_busy_buses other_busy_buses + 1
        ]
      ]
    ]
    
    ;if other_busy_buses >= min list max (list 1 length other-buses-on-my-line) 5
    if other_busy_buses = received_responses and received_responses > 0
    [
      show(word "Adding bus on line " line_id " because other buses are full")
      add-bus 3 line_id
    ]
      
    set inbox []
  ]
  
  
  ifelse length bus_passengers < (0.5 * capacity)
  [
    set color green;
  ]
  [
    ifelse length bus_passengers < (0.8 * capacity)
    [
      set color yellow;
    ]
    [
      ifelse length bus_passengers < (0.95 * capacity) 
      [
        set color orange;
      ]
      [
        set color red;
      ]
    ]
  ]
  
  let waiting_pass get_waiting_pass_for_line line_id
  if waiting_pass = 0 and length bus_passengers = 0
  [
    stop
  ]
  
  ; if we are busy, we ask 2 random other buses on our line if they are busy too
  let my_line_id line_id
  
  
  if length bus_passengers > (0.95 * capacity)
  [
    ifelse empty? other-buses-on-my-line
    [
      show(word "Adding a bus on line " line_id " because there are no other buses on this line yet")
      add-bus 3 line_id
    ]
    [
      let buses_asked 0
      let buses_busy 0
      let ask_n_buses min list 5 length other-buses-on-my-line

      let ask_bus_id n-of ask_n_buses other-buses-on-my-line
      let mess list 2 bus_id
      foreach ask_bus_id
      [
        send-message ?1 mess
      ]
    ] 
  ]
  
  
  
  if current_stop != -1
  [
    
    ; Always drop off passengers at their destination
    foreach bus_passengers
      [
        if current_stop = item 1 ? 
        [
          drop-off-passenger item 0 ? 
          ;show word "dropped off " item 0 ?
          ;show word "   at bus stop " current_stop
        ]
      ]
        
    let passengers-waiting get-passengers-at-stop current_stop
    
    ; Use Central Station as central location for all transfers
    ifelse current_stop = 3
    [
      ; First drop off, then collect 
      foreach bus_passengers
      [
         ; Drop off passengers at Central Station whose destination is not in the
         ; itinerary of the current bus, so they can switch buses 
         if not member? item 1 ? itinerary 
         [
           drop-off-passenger item 0 ?  
           ;show word "dropped off " item 0 ? 
           ;show word "   at bus stop " current_stop
         ]
       ]
        
       ; Similarly, check if there are passengers at Central (possibly dropped off
       ; by other buses) whose destination is in the itinerary of the current bus, and pick them up
       foreach passengers-waiting
       [
         if length bus_passengers < capacity
         [
           if member? item 1 ? itinerary 
           [
             ; Do not pick up passengers who are already at their destination
             if current_stop != item 1 ?
             [
               pick-up-passenger item 0 ? 
               ;show word "picked up " item 0 ? 
               ;show word "   at bus stop " current_stop
              ]
            ]
          ]
           
        ]
      ]
    
      ; At other stations, pick up anyone if capacity allows 
      [
        foreach passengers-waiting
        [
          if length bus_passengers < capacity
          [
            ; Do not pick up passengers who are already at their destination
            if current_stop != item 1 ?
            [
              pick-up-passenger item 0 ? 
              ;show word "picked up " item 0 ? 
              ;show word "   at bus stop " current_stop
            ]
          ]  
        ] 
      ]
   
    set route_position (route_position + direction) mod (length itinerary)        
  ]
  
  ;show route_position
  travel-to item route_position itinerary  
  
end


to-report get_waiting_pass_for_line [l_id]
  let stops get_stops_for_line l_id
  let pass 0
  
  foreach remove-duplicates stops
  [
    ask bus_stop ?1 
    [ 
      ifelse ?1 = 3
      [
        foreach passengers_waiting
        [
          let destination item 1 ?1
          if member? destination get_stops_for_line l_id
          [
            set pass pass + 1
          ]
        ]
      ]
      [
        set pass pass + length passengers_waiting
      ]
    ]
  ]
  report pass
  
end