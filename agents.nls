buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.

  ;next_options
  ;destination
  capacity
  
  next_bus_stop
  
  total_dropped_pass
  bus_data
  
  itinerary
  route_position
  direction       ; Direction wrt itinerary
  new-bus-counter
  bus_counter
  total_bus_capacity

]
 
globals [graph]

to init-buses
  ; Initialize your agents here.

  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]

  set amsterdam_bus_stops_names ["Amstel" "Amstelveenseweg" "Buikslotermeer" "Centraal" "Dam"
    "Evertsenstraat" "Floradorp" "Haarlemmermeerstation" "Hasseltweg" "Hendrikkade"
    "Leidseplein" "Lelylaan" "Muiderpoort" "Museumplein" "RAI" "SciencePark" "Sloterdijk"
    "Surinameplein" "UvA" "VU" "Waterlooplein" "Weesperplein" "Wibautstraat" "Zuid"]
  
  set new-bus-counter 10
  set bus_data []
  set bus_counter 1

  ; only use this to initialize agent variables, everything else in execute=actions 

  ifelse bus_type = 1
  [
    set capacity 12
  ]
  [
    ifelse bus_type = 2
    [
      set capacity 60 
    ]
    [
      set capacity 150
    ] 
  ]
  
  set route_position 0 
  
  set color green;
  
  set total_dropped_pass 0current_stop
end

to-report get-total-waiting-passengers 
  ; get the total number of waiting passengers at all stops
  let waiting-passengers 0
  let stop_ids n-values 23 [ ? + 1 ]
  foreach stop_ids [
    ;show(get-passengers-at-stop ?)
    set waiting-passengers waiting-passengers + length(get-passengers-at-stop ?)
  ]
  report waiting-passengers
end

to-report get-total-waiting-passengers-this-next-station
  ; get the total number of waiting passengers at all stops
  let waiting-passengers 0
  ; create list of all stops toobserve
  let connected-stops item current_stop graph
  set connected-stops sentence connected-stops item next_stop graph
  set connected-stops remove-duplicates connected-stops
  foreach connected-stops [
    ;show(get-passengers-at-stop ?)
    set waiting-passengers waiting-passengers + length(get-passengers-at-stop ?)
  ]
  report waiting-passengers
end  

to-report inbox-duplicate list element
  foreach list
  [
    if item 1 ? element
    [
      report position element list
    ]
  ]
  report False
end

to-report capacity-needs bus_data
  let capacity_need 0
  foreach bus_data
  [
    set capacity_need capacity_need + (last ?)
  ]
  report capacity_need
end

to-report decide_bus_type [capacity bus_counter total_bus_capacity]
  ifelse bus_type = 1
  [
    set capacity 12
  ]
  [
    ifelse bus_type = 2
    [
      set capacity 60 
    ]
    [
      set capacity 150
    ] 
  ]

to execute-actions
  
  if bus_id = 24
  [
    let capacity-vote 0
    foreach inbox
    [
      if inbox-duplicate bus_data (item 1 ?) 
      [
        set bus_data remove-item ( inbox-duplicate bus_data (item 1 ?)) bus_data
      ]     
      set bus_data [bus_data ?]
    ]
    if new-bus-counter = 0 
    [
      let capacity_need capacity-needs bus_data
      let bus_type decide_bus_type [capacity_need bus_counter total_bus_capacity]
      if 
      [
        add-bus 
      
      ; if added bus
      set bus_counter bus_counter + 1
      set total_bus_capacity total_bus_capacity + capacity
      
      set bus_data []
    ]
    
        
    
  ]
  
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.
  let xs [27 11 31 22 21 11 25 11 26 25 17 4 31 17 19 35 6 10 38 14 23 24 25 15]
  let ys [7 4 30 21 18 18 30 9 24 18 14 12 13 11 3 10 26 13 11 1 16 13 11 4]
  
  ifelse length bus_passengers < (0.5 * capacity)
  [
    set color green;
  ]
  [
    ifelse length bus_passengers < (0.8 * capacity)
    [
      set color yellow;
    ]
    [
      ifelse length bus_passengers < (0.95 * capacity) 
      [
        set color orange;
      ]
      [
        set color red;
      ]
    ]
  ]
  
  
  if current_stop != -1
  [    
    
    ; Always drop off passengers at their destination

    foreach bus_passengers
    [
      if current_stop = item 1 ? 
      [
        drop-off-passenger item 0 ? 
        set total_dropped_pass total_dropped_pass + 1
      ]
    ]
    ; show(word "Total dropped off " total_dropped_pass)
    
    ; Find the connected bus stops
    let connected_bus_stops item current_stop graph
    
    ; Find the names of the connected bus stops, and the amount of passengers waiting at these stops
    let stop_names []
    let pass_waiting_at_next_stops []
    foreach connected_bus_stops
    [
      let stop_name item ?1 amsterdam_bus_stops_names
      set stop_names lput stop_name stop_names
      let pass_waiting_at_next_stop length get-passengers-at-stop ?1
      set pass_waiting_at_next_stops lput pass_waiting_at_next_stop pass_waiting_at_next_stops
    ]
    
    ;show(word "Possible next stops" stop_names)
    ;show(word "Passengers waiting at next stops: " pass_waiting_at_next_stops)
    
    let passenger_votes n-values length connected_bus_stops [0]
    if length bus_passengers != 0
    [
      foreach bus_passengers
      [
        let destination item 1 ?1
        let destination_x_cor item destination xs
        let destination_y_cor item destination ys
        
        let distances []
        foreach connected_bus_stops
        [
          let stop_x_cor item ?1 xs
          let stop_y_cor item ?1 ys
          
          let dist sqrt ((stop_x_cor - destination_x_cor)*(stop_x_cor - destination_x_cor) + (stop_y_cor - destination_y_cor)*(stop_y_cor - destination_y_cor))
          set distances lput dist distances
        ]
        ;show(word "Destination " item destination amsterdam_bus_stops_names)
        ;show(word "Distances: " distances)
        
        let min_distance min distances
        let argmin position min_distance distances
        let best_bus_stop item argmin connected_bus_stops
        
        let old_value item argmin passenger_votes
        ifelse best_bus_stop = destination
        [
          set passenger_votes replace-item argmin passenger_votes (old_value + 2)
        ]
        [
          set passenger_votes replace-item argmin passenger_votes (old_value + 1)
        ]
      ]
    ]
    
    ;show(word "Number of passengers " length bus_passengers)
    
    ;show(word "Passenger votes: " passenger_votes)
    
    ;let total_votes []
    ;(foreach pass_waiting_at_next_stops passenger_votes 
    ;[
    ;  set total_votes lput (?1 + ?2 * 10) total_votes
    ;])
    
    let total_votes passenger_votes
    
    ;show(word "Total votes: " total_votes)
       
    
    ; Find the argmax of the list with passengers waiting at connected bus stops (netlogo has no direct argmax function)
    let max_passengers max total_votes
    let argmaxs []
    let index 0
    foreach total_votes
    [
      if max_passengers = ?1
      [
        set argmaxs lput index argmaxs
        
      ]
      set index index + 1
    ]
    
    let argmax one-of argmaxs
    ;let argmax position max_passengers total_votes
    
    
    ; Determine what the next bus stop is
    set next_bus_stop item argmax connected_bus_stops
    let next_bus_stop_name item next_bus_stop amsterdam_bus_stops_names
    
    
    let all_zero true
    foreach total_votes
    [
      set all_zero all_zero and ?1 = 0
    ]
    
    if all_zero
    [
      set next_bus_stop one-of connected_bus_stops
    ]
    
    ;show(word "Next bus stop: " next_bus_stop_name)
    
    let current_stop_x_cor item current_stop xs
    let current_stop_y_cor item current_stop ys
    
    let next_stop_x_cor item next_bus_stop xs
    let next_stop_y_cor item next_bus_stop ys
    
    ; Drop the passengers if the next stop doesn't bring them closer to their final destination
    if length bus_passengers != 0
    [
      foreach bus_passengers
      [
        let destination item 1 ?1
        let destination_x_cor item destination xs
        let destination_y_cor item destination ys
        
        ;show(word "Destination of passenger: " item destination amsterdam_bus_stops_names)
        
        let dist_here_to_dest sqrt ((current_stop_x_cor - destination_x_cor)*(current_stop_x_cor - destination_x_cor) + (current_stop_y_cor - destination_y_cor)*(current_stop_y_cor - destination_y_cor))
        let dist_next_stop_to_dest sqrt ((next_stop_x_cor - destination_x_cor)*(next_stop_x_cor - destination_x_cor) + (next_stop_y_cor - destination_y_cor)*(next_stop_y_cor - destination_y_cor))
        
        
        
        ;show(word "Current stop " item current_stop amsterdam_bus_stops_names "Next stop "  next_bus_stop_name)
        if dist_next_stop_to_dest > dist_here_to_dest
        [
          ;show(word "So dropping passenger with destination " item destination amsterdam_bus_stops_names)
          drop-off-passenger item 0 ? 
        ]
      ]
    ]
    
    ; Decide on the necesary extra capacity needed to cover the system
    
    let total-waiting-passengers get-total-waiting-passengers-this-next-station
    
    show(total-waiting-passengers)
    
    
    set new-bus-counter new-bus-counter - 1
    if new-bus-counter = 0 
    [
      if (capacity - length bus_passengers) * 0.8 < total-waiting-passengers 
      [
        ; Compute the capacity vote
        let capacity-vote (total-waiting-passengers - (capacity - length bus_passengers) * 0.8) 
        ;send message
        let message list bus_id capacity-vote current_stop
        send-message 24 message
        
      ]
      set new-bus-counter 10
    ]
    
    
    let passengers-waiting get-passengers-at-stop current_stop
    
    ; At other stations, pick up anyone if capacity allows 
    foreach passengers-waiting
    [
      if length bus_passengers < capacity
      [
        ; Do not pick up passengers who are already at their destination
        if current_stop != item 1 ?
        [
          pick-up-passenger item 0 ? 
          ;show word "picked up " item 0 ? 
          ;show word "   at bus stop " current_stop
        ]
      ]  
    ]     
  ]
  
  ;show route_position
  travel-to next_bus_stop  
  
  
end