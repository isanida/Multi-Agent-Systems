buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.

  ;next_options
  ;destination
  capacity
  line_id
  itinerary
  route_position
  direction       ; Direction wrt itinerary

]
 
globals [graph]

to init-buses
  ; Initialize your agents here.

  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]

  ; only use this to initialize agent variables, everything else in execute=actions 

  show (word "Adding bus of type " bus_type " and id " bus_id)

  if bus_type = 1
  [
    
    set capacity 12
  ]
  
  if bus_type = 2
  [
    set capacity 60
  ]
  
  if bus_type = 3
  [
    set capacity 150
  ]

  
  ; North line
  if member? bus_id [24 28 32 36 40 44]
  [
     set-line 1
  ]
  
  ; East line
  if  member? bus_id [25 29 33 37 41 45]
  [
     set-line 2
  ]
  
  ; South line
  if  member? bus_id [26 30 34 38 42 46]
  [
     set-line 3 
  ]
  
  ; West line
  if  member? bus_id [27 31 35 39 43 47]
  [
     set-line 4
  ]
  
  set route_position 0 
  
  ifelse (bus_id mod 2) = 0 
  [
    set direction 1 
  ]
  [
    set direction -1 
  ]
  
  set color green;
  

end


to set-line [line_idd]
  set line_id line_idd
  set itinerary get_stops_for_line line_idd
end

to-report get_stops_for_line [l_id]
  ; North line
  if l_id = 1
  [
    report [3 9 8 2 8 6 8 9]
  ]
  
  ; East line
  if l_id = 2
  [
    report [3 20 12 15 18 15 0 22 21 20]
  ]
  
  ; South line
  if l_id = 3
  [
    report [3 4 10 13 23 14 23 19 1 7 17 10 4] 
  ]
  
  ; West line
  if l_id = 4
  [
    report [3 4 5 17 11 16] 
  ]
end


to execute-actions
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.
  
  if bus_id = 24
  [
    if (count buses) < 4
    [
      ; Just add 19 buses :)
      
      let i (minutes)
      
      if ticks mod 5 = 0 [
        add-bus 1
      ]
    ]
  ]
  
  let waiting_pass get_waiting_pass_for_line line_id
  show(word "Waiting passengers for line " line_id " : " waiting_pass)
  
  
  ifelse length bus_passengers < (0.5 * capacity)
  [
    set color green;
  ]
  [
    ifelse length bus_passengers < (0.8 * capacity)
    [
      set color yellow;
    ]
    [
      ifelse length bus_passengers < (0.95 * capacity) 
      [
        set color orange;
      ]
      [
        set color red;
      ]
    ]
  ]
  
  
  
  
  if current_stop != -1
  [
    
    ; Always drop off passengers at their destination
    foreach bus_passengers
      [
        if current_stop = item 1 ? 
        [
          drop-off-passenger item 0 ? 
          ;show word "dropped off " item 0 ?
          ;show word "   at bus stop " current_stop
        ]
      ]
        
    let passengers-waiting get-passengers-at-stop current_stop
    
    ; Use Central Station as central location for all transfers
    ifelse current_stop = 3
    [
      ; First drop off, then collect 
      foreach bus_passengers
      [
         ; Drop off passengers at Central Station whose destination is not in the
         ; itinerary of the current bus, so they can switch buses 
         if not member? item 1 ? itinerary 
         [
           drop-off-passenger item 0 ?  
           ;show word "dropped off " item 0 ? 
           ;show word "   at bus stop " current_stop
         ]
       ]
        
       ; Similarly, check if there are passengers at Central (possibly dropped off
       ; by other buses) whose destination is in the itinerary of the current bus, and pick them up
       foreach passengers-waiting
       [
         if length bus_passengers < capacity
         [
           if member? item 1 ? itinerary 
           [
             ; Do not pick up passengers who are already at their destination
             if current_stop != item 1 ?
             [
               pick-up-passenger item 0 ? 
               ;show word "picked up " item 0 ? 
               ;show word "   at bus stop " current_stop
              ]
            ]
          ]
           
        ]
      ]
    
      ; At other stations, pick up anyone if capacity allows 
      [
        foreach passengers-waiting
        [
          if length bus_passengers < capacity
          [
            ; Do not pick up passengers who are already at their destination
            if current_stop != item 1 ?
            [
              pick-up-passenger item 0 ? 
              ;show word "picked up " item 0 ? 
              ;show word "   at bus stop " current_stop
            ]
          ]  
        ] 
      ]
   
    set route_position (route_position + direction) mod (length itinerary)        
  ]
  
  ;show route_position
  travel-to item route_position itinerary  
  
  
end

to-report get_waiting_pass_for_line [l_id]
  let stops get_stops_for_line l_id
  let pass 0
  
  foreach remove-duplicates stops
  [
    
    ask bus_stop ?1 
    [ 
      if ?1 != 3
      [
         set pass pass + length passengers_waiting
      ]
    ]
    
    
    ;let info get-passengers-at-stop l_id
    ;show(info)
    ;set pass pass + count get-passengers-at-stop l_id
  ]
  report pass
end