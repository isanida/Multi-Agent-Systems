buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.

  ;next_options
  ;destination
  capacity
  
  next_bus_stop
  
  total_dropped_pass
  bus_data
  
  itinerary
  route_position
  direction       ; Direction wrt itinerary
  new-bus-counter
  bus_counter
  total_bus_capacity
  capacity_need
]
 
globals [graph xcs ycs distance_table]





to init-buses
  ; Initialize your agents here.

  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]

  set amsterdam_bus_stops_names ["Amstel" "Amstelveenseweg" "Buikslotermeer" "Centraal" "Dam"
    "Evertsenstraat" "Floradorp" "Haarlemmermeerstation" "Hasseltweg" "Hendrikkade"
    "Leidseplein" "Lelylaan" "Muiderpoort" "Museumplein" "RAI" "SciencePark" "Sloterdijk"
    "Surinameplein" "UvA" "VU" "Waterlooplein" "Weesperplein" "Wibautstraat" "Zuid"]
  
  if distance_table = 0
  [
    set distance_table n-values 24 [n-values 24 [0]]
  ]
  
  

  set new-bus-counter 10
  set bus_data []
  set bus_counter 1

  set xcs [27 11 31 22 21 11 25 11 26 25 17 4 31 17 19 35 6 10 38 14 23 24 25 15]
  set ycs [7 4 30 21 18 18 30 9 24 18 14 12 13 11 3 10 26 13 11 1 16 13 11 4]


  ; only use this to initialize agent variables, everything else in execute=actions 

  ifelse bus_type = 1
  [
    set capacity 12
  ]
  [
    ifelse bus_type = 2
    [
      set capacity 60 
    ]
    [
      set capacity 150
    ] 
  ]
  
  set route_position 0 
  
  set color green;
  
  set total_dropped_pass current_stop
end

to-report get-total-waiting-passengers 
  ; get the total number of waiting passengers at all stops
  let waiting-passengers 0
  let stop_ids n-values 23 [ ? + 1 ]
  foreach stop_ids [
    ;show(get-passengers-at-stop ?)
    set waiting-passengers waiting-passengers + length(get-passengers-at-stop ?)
  ]
  report waiting-passengers
end


to-report get-total-waiting-passengers-this-next-station
  ; get the total number of waiting passengers at all stops
  let waiting-passengers length(get-passengers-at-stop current_stop)
  ; create list of all stops toobserve
  let connected-stops item current_stop graph
  if next_stop > -1
  [
    set connected-stops sentence connected-stops item next_stop graph
    set connected-stops remove-duplicates connected-stops
    foreach connected-stops [
      ;show(get-passengers-at-stop ?)
      set waiting-passengers waiting-passengers + length(get-passengers-at-stop ?)
    ]
  ]
  report waiting-passengers
end  

to-report inbox-duplicate [list1 element]
  foreach list1
  [
    if item 1 ? = element
    [
      report position element list1
    ]
  ]
  report False
end

to-report capacity-needs 
  set capacity_need 0
  foreach bus_data
  [
    ;show(?)
    set capacity_need capacity_need + (last ?)
  ]
  report capacity_need
end

to-report decide_bus_type
  ; Given the needed extra capacity and the total capacity of the current busses
  ; Find the needed capacity of the new bus
  let bus_no_factor (-1 / 80) * bus_counter + 1
;  show(bus_no_factor)
  let bustype 0
  let final_capacity_need capacity_need
  if random-float 1 < bus_no_factor
  [
    ifelse final_capacity_need < 6
    [
      set bustype 0
    ]
    [
      ifelse final_capacity_need < 36
      [
        set bustype 1
      ]
      [
        ifelse final_capacity_need < 105
        [
          set bustype 2
        ]
        [
          set bustype 3
        ] 
      ]
    ]
  ;  if final_capacity_need > 150
  ;  [
  ;    set bustype 3
  ;  ]
  ]
  report bustype
end


to-report get_next_bus_stop_from_votes [votes connected_bus_stops current_stop_x_cor current_stop_y_cor]
  ; Find the argmax of the list with passengcreate list of lists netlogoers waiting at connected bus stops (netlogo has no direct argmax function)
  let max_votes max votes
  let argmaxs []
  let index 0
  foreach votes
  [
    if max_votes = ?1
    [
      set argmaxs lput index argmaxs
      
    ]
    set index index + 1
  ]

  let following_stop 0
  ifelse max_votes = 0
  [
    set following_stop one-of connected_bus_stops
  ]
  [
    set following_stop item (one-of argmaxs) connected_bus_stops
  ]
  
  report following_stop
  
end

to print-for-single-bus [id message]
  if bus_id = id
  [
    ;show(message)
  ]
end


to execute-actions
  
;  if bus_id = 24
;  [
;    if ticks mod 20 = 0 and bus_id = 24 and count buses < 40
;    [
;      add-bus 3
;    ]
;  ]
;  
  
  if bus_id = 24
  [
    ifelse bus_counter < 4
    [
      add-bus 3
      set bus_counter bus_counter + 1
      set total_bus_capacity total_bus_capacity + capacity
    ]
    [

      let capacity-vote 0
      
      foreach inbox
      [
        
        ;show(word "inbox")
        ;show(word "Inbox " ?1)
        if length(bus_data) > 0
        [
          if inbox-duplicate bus_data (item 1 (last ?))
          [
            set bus_data remove-item ( inbox-duplicate bus_data (item 3 ?)) bus_data
          ]     
          
        ]
        ifelse length bus_data > 0
        [
          set bus_data lput (last ?) bus_data 
        ]
        [
          let data last ?
          set bus_data []
          set bus_data lput data bus_data 
        ]
        set inbox []
      ]
      ;show(word "data")
      ;show bus_data
      if new-bus-counter = 0 
      [
        ;show(word "Working?")
        set capacity_need capacity-needs
;        show(word "Capacity_need is: " capacity_need)
        let bustype decide_bus_type
        ;show(word "New bus type is: " bustype)
        ; if decide to add bus
        if bustype > 0
        [
          add-bus bustype
          ;show(word "New bus initialized")
          set bus_counter bus_counter + 1
          set total_bus_capacity total_bus_capacity + capacity
          set bus_data []
        ]     
      ]     
    ]
  ]
  
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.
  
  
  ifelse length bus_passengers < (0.5 * capacity)
  [
    set color green;
  ]
  [
    ifelse length bus_passengers < (0.8 * capacity)
    [
      set color yellow;
    ]
    [
      ifelse length bus_passengers < (0.95 * capacity) 
      [
        set color orange;
      ]
      [
        set color red;
      ]
    ]
  ]
  
  
  if current_stop != -1
  [
    let message (word " ")
    ;print-for-single-bus 24 message
    
    ;let dist_to_cent get_dist_using_dijkstra current_stop 3
    ;set message (word "Distance to Central: " dist_to_cent)
    ;print-for-single-bus 24 message
    
    
    let current_stop_x_cor item current_stop xcs
    let current_stop_y_cor item current_stop ycs
    
    ; Always drop off passengers at their destination
    foreach bus_passengers
    [
      if current_stop = item 1 ?
      [
        set total_dropped_pass total_dropped_pass + 1
      ]

      drop-off-passenger item 0 ? 
    ]
    
    set message (word "Total succesfully dropped off " total_dropped_pass)
    ;print-for-single-bus 24 message
    
    
    ; Find the connected bus stops
    let connected_bus_stops item current_stop graph
    
    
    ; Find the names of the connected bus stops, and the amount of passengers waiting at these stops
    let stop_names []
    let pass_waiting_at_next_stops []
    let print_votes false
    foreach connected_bus_stops
    [
      let stop_name item ?1 amsterdam_bus_stops_names
      set stop_names lput stop_name stop_names
      let pass_waiting_at_next_stop 0
      ifelse current_stop = 9 and ?1 = 8
      [
        set pass_waiting_at_next_stop (length get-passengers-at-stop 8 + length get-passengers-at-stop 2 + length get-passengers-at-stop 6)
        ;show(word "North passengers: " pass_waiting_at_next_stop)
        set print_votes true
      ]
      [
        set pass_waiting_at_next_stop length get-passengers-at-stop ?1
      ]
      
      set pass_waiting_at_next_stops lput pass_waiting_at_next_stop pass_waiting_at_next_stops
    ]
    
    
    ;show(word "Connected bus stops: " stop_names)
    
    ; Initialized an array to keep the votes for each connected bus stop
    let votes n-values length connected_bus_stops [0]
    
    let pass_at_this_stop get-passengers-at-stop current_stop
    ;show(word "Number of passengers at this stop: " length pass_at_this_stop)
    set message (word "Number of passengers at this stop: " length pass_at_this_stop)
    ;print-for-single-bus 24 message
    
    
    foreach pass_at_this_stop
    [
      let pass_id item 0 ?1
      let pass_info item pass_id passengers
      let dest item 3 pass_info
      let pass_travel_time item 5 pass_info
      let n_votes ceiling (pass_travel_time / 5)
      
      let destination_x_cor item dest xcs
      let destination_y_cor item dest ycs
      
      let distances []
      foreach connected_bus_stops
      [
        ;let stop_x_cor item ?1 xcs
        ;let stop_y_cor item ?1 ycs
        
        let dist get_dist_using_dijkstra ?1 dest
        set distances lput dist distances
      ]
      
      let sorted_distances sort distances
      
      let indices n-values length distances [?]
      foreach indices
      [
        let dist item ?1 distances
        let rank position dist sorted_distances
        let this_bus_stop item ?1 connected_bus_stops
        
;        let amount_of_votes (length distances - rank - 1) * (n_votes + 1)
        let amount_of_votes (length distances - rank - 1)
        
        ;let message (word "Dest " item dest amsterdam_bus_stops_names " so voting " amount_of_votes " for " item this_bus_stop amsterdam_bus_stops_names)
        ;print-for-single-bus 24 message
        ;show(word "Dest " item dest amsterdam_bus_stops_names " so voting " amount_of_votes " for " item this_bus_stop amsterdam_bus_stops_names)
        
        let old_value item ?1 votes
        ifelse this_bus_stop = dest
        [
          set votes replace-item ?1 votes ((old_value + amount_of_votes) * 2)
        ]
        [
          set votes replace-item ?1 votes (old_value + amount_of_votes)
        ]
      ]
    ]
    
    
    
    let total_votes []
    (foreach votes pass_waiting_at_next_stops [
      set total_votes lput (?1 + 10 * (?2)) total_votes
    ])
    

    ;let total_votes votes
    
    set message word "Total votes: " total_votes
    ;print-for-single-bus 24 message
    
    
    let following_stop get_next_bus_stop_from_votes total_votes connected_bus_stops current_stop_x_cor current_stop_y_cor
    ;show(word "Following stop " following_stop " next stop " next_stop)
    if following_stop = previous_stop and following_stop != -1
    [
      let idx position following_stop connected_bus_stops
      ;show(word "idx " idx " votes " votes)
      set votes replace-item idx votes 0
      set following_stop get_next_bus_stop_from_votes votes connected_bus_stops current_stop_x_cor current_stop_y_cor
    ]
    
    ;show(word "Total votes: " total_votes)
    ifelse amount_passengers_waiting = 0
    [
      ifelse length bus_passengers = 0
      [
        set next_bus_stop current_stop
      ]
      [
        set next_bus_stop following_stop
      ]
    ]
    [
      set next_bus_stop following_stop
    ]         

    ; Decide on the necesary extra capacity needed to cover the system
    
    let total-waiting-passengers get-total-waiting-passengers-this-next-station
    
    ;show(total-waiting-passengers)
    
    if next_bus_stop != current_stop
    [
      if new-bus-counter = 0 
      [
        ;show(word " busjee")
        if bus_id > 24
        [
          ;if (capacity - length bus_passengers) * 0.8 < total-waiting-passengers 
          ; Compute the capacity vote
          let capacity-vote (total-waiting-passengers - (capacity - length bus_passengers) * 0.8) 
          ;send message
          set message (list bus_id capacity-vote current_stop)
          ;show message
          send-message 24 message
          
        ]
        set new-bus-counter 10
      ]
      set new-bus-counter new-bus-counter - 1
  
      let next_bus_stop_name 0
      set next_bus_stop_name item next_bus_stop amsterdam_bus_stops_names
      ;show(word "Next bus stop: " next_bus_stop_name)
      set message word "Next bus stop: " next_bus_stop_name
      ;print-for-single-bus 24 message
      
      let next_stop_x_cor item next_bus_stop xcs
      let next_stop_y_cor item next_bus_stop ycs
  
      
      let passengers-waiting get-passengers-at-stop current_stop
      
      ; At other stations, pick up anyone if capacity allows 
      let pickedup 0
      foreach passengers-waiting
      [
        let destination item 1 ?1
        ifelse length bus_passengers < capacity
        [
          ; Do not pick up passengers who are already at their destination
          ifelse current_stop != item 1 ?
          [
  
            let dist_here_to_dest get_dist_using_dijkstra current_stop destination
            let dist_next_stop_to_dest get_dist_using_dijkstra next_bus_stop destination
            
            let is_next_stop_connected_to_dest member? destination (item next_bus_stop graph)
            
            ifelse dist_next_stop_to_dest < dist_here_to_dest or is_next_stop_connected_to_dest
            [
              pick-up-passenger item 0 ? 
              set pickedup pickedup + 1
              ;show(word "Picked up passenger going to " item destination amsterdam_bus_stops_names)
            ]
            [
              set message (word "Didn't pick up pass going to " item destination amsterdam_bus_stops_names " because it is further away")
              ;print-for-single-bus 24 message
            ]
          ]
          [
            ;show(word "Didn't pick up pass going to " item destination amsterdam_bus_stops_names " because we are already there")
            set message (word "Didn't pick up pass going to " item destination amsterdam_bus_stops_names " because we are already there")
            ;print-for-single-bus 24 message
          ]
        ]
        [
          ;show(word "Didn't pick up pass going to " item destination amsterdam_bus_stops_names " because bus is full")
        ]
      ]    
      
      set message word "Picked up passengers: " pickedup
      ;print-for-single-bus 24 message
      set message word "Next bus stop: " next_bus_stop_name
      ;print-for-single-bus 24 message
    ]
    ;show route_position
    
  ]
  if next_bus_stop != current_stop
  [
;    show(word "next bus stop: " next_bus_stop)
;    show(word "current bus stop: " current_stop)
    travel-to next_bus_stop 
  ]
  
  
  
  
end
