buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.

  ;next_options
  ;destination
  capacity
  line_id
  itinerary
  route_position
  direction       ; Direction wrt itinerary
  other-buses-on-my-line
]
 
globals [graph]

to init-buses
  ; Initialize your agents here.
  
  set inbox []
  set other-buses-on-my-line []

  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]

  ; only use this to initialize agent variables, everything else in execute=actions 

  show (word "Adding bus of type " bus_type " and line " line_id)

  if bus_type = 1
  [
    
    set capacity 12
  ]
  
  if bus_type = 2
  [
    set capacity 60
  ]
  
  if bus_type = 3
  [
    set capacity 150
  ]

  set-line line_id
  
  ; North line
  ;if member? bus_id [24]
  ;[
  ;   set-line 1
  ;]
  
  ; East line
  ;if  member? bus_id [25]
  ;[
  ;  set-line 2
  ;]
  
  ; South line
  ;if  member? bus_id [26]
  ;[
  ;   set-line 3 
  ;]
  
    ; West line
  ;if  member? bus_id [27]
  ;[
  ;   set-line 4
  ;]
  
  set route_position 0 
  
  ifelse (bus_id mod 2) = 0 
  [
    set direction 1 
  ]
  [
    set direction -1 
  ]
  
  set color green;
  

end


to set-line [line_idd]
  set line_id line_idd
  set itinerary get_stops_for_line line_idd
  let my_id bus_id
  ask buses
  [
    let mess list 1 my_id
    set mess lput line_idd mess
    
    if bus_id != my_id
    [
      send-message bus_id mess
    ]
  ]
end


to-report get_stops_for_line [l_id]
  ; North line
  if l_id = 1
  [
    report [3 9 8 2 8 6 8 9]
  ]
  
  ; East line
  if l_id = 2
  [
    report [3 20 12 15 18 15 0 22 21 20]
  ]
  
  ; South line
  if l_id = 3
  [
    report [3 4 10 13 23 14 23 19 1 7 17 10 4] 
  ]
  
  ; West line
  if l_id = 4
  [
    report [3 4 5 17 11 16] 
  ]
end


to execute-actions
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.
  
  if bus_id = 24
  [
    if (count buses) < 4
    [
      ; Just add 4 buses :)
      
      if ticks mod 5 = 0 [
        add-bus 3 count buses + 1
      ]
    ]
  ]
  if ticks mod 10 = 0 
  [
    ask buses
    [
      if bus_id = 1
      [

        foreach n-values (count buses - 2) [ ? + 1]
        [
          let response list 1 0
          send-message (?+2) response
        ]
      ]
    ]
  ]
  
  
  let total_vote 0
  if length inbox > 0
  [    
    foreach inbox
    [
      ; type 1 message
      if item 0 item 2 ?1 = 1
      [
        ; Get the number of passengers on the bus and the number os potential passengers.
        ; Use this number to calculate the vote probability
        ; Using: voteprob = ((bus_passengers/bus_capacity) + (Waiting_next_stations/total_waiting)) / 2
        ; Send this information back to bus 1
        let vote_prob 0
        let total_pass total_waiting_passengers current_stop
        if bus_passengers > 0.8 * capacity 
        [
          set vote_prob vote_prob + (bus_passengers / capacity)
        ]
        let other_stations get_waiting_pass_for_next_stations current_stop
        let all_waiting total_waiting_passengers current_stop
        set vote_prob vote_prob + (other_stations / all_waiting)
        set vote_prob vote_prob / 2
        let response list 2 vote_prob
        send-message 1 response
      ]
      
      ; type 2 message
      if item 0 item 2 ?1 = 2
      [
        let vote_prob 0
        ; Get the vote of bus 1
        ; F
        if bus_passengers > 0.8 * capacity 
        [
          set vote_prob vote_prob + (bus_passengers / capacity)
        ]
        let other_stations get_waiting_pass_for_next_stations current_stop
        let all_waiting total_waiting_passengers current_stop
        set vote_prob vote_prob + (other_stations / all_waiting)
        set total_vote total_vote + vote_prob
        
        ; Receive votes from the other busses
        set vote_prob item 1 item 2 ?1
        set total_vote total_vote + vote_prob
        show(word "Received response " vote_prob)
        
        
      ]
      
;      ; type 3 message
;      if item 0 item 2 ?1 = 3
;      [
;        set received_responses received_responses + 1
;        let fullness item 1 item 2 ?1
;        show(word "Received response " fullness)
;        if fullness = 1
;        [
;          set other_busy_buses other_busy_buses + 1
;        ]

    set total_vote (total_vote / (count buses))
    ;if other_busy_buses >= min list max (list 1 length other-buses-on-my-line) 5
    if total_vote > 0.7
    [
      show(word "Adding bus on line " line_id " because other buses are full")
      ; TODO (Remove random here cause now it initializes a random line)
      add-bus 3 (random (4 - 1) + 1)
    ]
      
    set inbox []
  ]
 ]
  
  
  ifelse length bus_passengers < (0.5 * capacity)
  [
    set color green;
  ]
  [
    ifelse length bus_passengers < (0.8 * capacity)
    [
      set color yellow;
    ]
    [
      ifelse length bus_passengers < (0.95 * capacity) 
      [
        set color orange;
      ]
      [
        set color red;
      ]
    ]
  ]
  
  let waiting_pass get_waiting_pass_for_line line_id
  if waiting_pass = 0 and length bus_passengers = 0
  [
    stop
  ]
  
  ; if we are busy, we ask 2 random other buses on our line if they are busy too
  let my_line_id line_id
  
  
  if length bus_passengers > (0.95 * capacity)
  [
    ifelse empty? other-buses-on-my-line
    [
      show(word "Adding a bus on line " line_id " because there are no other buses on this line yet")
      add-bus 3 line_id
    ]
    [
      let buses_asked 0
      let buses_busy 0
      let ask_n_buses min list 5 length other-buses-on-my-line

      let ask_bus_id n-of ask_n_buses other-buses-on-my-line
      let mess list 2 bus_id
      foreach ask_bus_id
      [
        send-message ?1 mess
      ]
    ] 
  ]
  
  
  
  if current_stop != -1
  [
    
    ; Always drop off passengers at their destination
    foreach bus_passengers
      [
        if current_stop = item 1 ? 
        [
          drop-off-passenger item 0 ? 
          ;show word "dropped off " item 0 ?
          ;show word "   at bus stop " current_stop
        ]
      ]
        
    let passengers-waiting get-passengers-at-stop current_stop
    
    ; Use Central Station as central location for all transfers
    ifelse current_stop = 3
    [
      ; First drop off, then collect 
      foreach bus_passengers
      [
         ; Drop off passengers at Central Station whose destination is not in the
         ; itinerary of the current bus, so they can switch buses 
         if not member? item 1 ? itinerary 
         [
           drop-off-passenger item 0 ?  
           ;show word "dropped off " item 0 ? 
           ;show word "   at bus stop " current_stop
         ]
       ]
        
       ; Similarly, check if there are passengers at Central (possibly dropped off
       ; by other buses) whose destination is in the itinerary of the current bus, and pick them up
       foreach passengers-waiting
       [
         if length bus_passengers < capacity
         [
           if member? item 1 ? itinerary 
           [
             ; Do not pick up passengers who are already at their destination
             if current_stop != item 1 ?
             [
               pick-up-passenger item 0 ? 
               ;show word "picked up " item 0 ? 
               ;show word "   at bus stop " current_stop
              ]
            ]
          ]
           
        ]
      ]
    
      ; At other stations, pick up anyone if capacity allows 
      [
        foreach passengers-waiting
        [
          if length bus_passengers < capacity
          [
            ; Do not pick up passengers who are already at their destination
            if current_stop != item 1 ?
            [
              pick-up-passenger item 0 ? 
              ;show word "picked up " item 0 ? 
              ;show word "   at bus stop " current_stop
            ]
          ]  
        ] 
      ]
   
    set route_position (route_position + direction) mod (length itinerary)        
  ]
  
  ;show route_position
  travel-to item route_position itinerary  
  
end

  
to-report total_waiting_passengers [stop_id]
  let pass 0
  let stops all_stops stop_id
  foreach remove-duplicates stops
  [
    foreach passengers_waiting
    [
      set pass pass + length passengers_waiting
    ]
  ]
  report pass
end

  
to-report all_stops [stop_id]
  let stops sentence graph
;  foreach graph
;  [set stops ? stops]
  remove stops stop_id
  report stops
end
    
to-report next_possible_stops [stop_id]
  let stops []
  foreach graph
  [
    if member? stop_id ?
    [
      set stops lput (remove ? stop_id) stops
    ]
  ]

  report stops
end
      
    
to-report get_waiting_pass_for_next_stations [b_id]
  ask buses
  [
    let pass 0
    let bus_stop current_stop
    let next_stops next_possible_stops bus_stop
    foreach remove-duplicates next_stops
    [
      ask bus_stop ?
      [
        foreach passengers_waiting
        [
          set pass pass + length passengers_waiting
        ]
      ]
    ]
  ]
  report pass
end
  

to-report get_waiting_pass_for_line [l_id]
  ; TODO return a list of bus_stops instead of bus_stop ids for ask bus_stop ?
  let stops get_stops_for_line l_id
  let pass 0
  
  foreach remove-duplicates stops
  [
    
    ask bus_stop ?
    [ 
      ifelse ?1 = 3
      [
        foreach passengers_waiting
        [
          let destination item 1 ?1
          if member? destination get_stops_for_line l_id
          [
            set pass pass + 1
          ]
        ]
      ]
      [
        set pass pass + length passengers_waiting
      ]
    ]
  ]
  report pass
  
end